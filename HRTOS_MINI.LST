C51 COMPILER V9.00   HRTOS_MINI                                                            12/22/2018 18:13:08 PAGE 1   


C51 COMPILER V9.00, COMPILATION OF MODULE HRTOS_MINI
NO OBJECT MODULE REQUESTED
COMPILER INVOKED BY: F:\C51\BIN\C51.EXE ..\HRTOS_MINI.c DEBUG OBJECTEXTEND SRC(.\HRTOS_MINI.SRC)

line level    source

   1          #include <reg52.h>
   2          #include<hrtos_mini.h>
   3          #define OS_ST 9   //保存的堆栈数
   4          unsigned char os_en_cr_count;
   5          unsigned char code os_map_tbl[] = {0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80};
   6          TCB os_tcb[MAX_TASKS];
   7          unsigned char os_task_running_id;//当前运行的任务号
   8          unsigned char os_task_rdy_tbl;//任务状态
   9          unsigned char  os_task_stack[MAX_TASKS][8];//任务堆栈区
  10          unsigned char os_hrtos_stack[26];//HRTOS堆栈区
  11          unsigned char os_stack;//堆栈初始值
  12          bit os_hrtos_wait;
  13          void timer0_isr(void) interrupt 1
  14          {
  15   1          unsigned char i,j;
  16   1          TF0=0;
  17   1              if(os_task_running_id==MAX_TASKS)
  18   1              {
  19   2                      ET0=0;
  20   2                      i=0;
  21   2                      goto OS_HRT;
  22   2              }
  23   1          os_tcb[os_task_running_id].os_task_stack_top=SP;
  24   1          j= SP-OS_ST-os_stack;
  25   1          if(os_hrtos_wait)
  26   1          {
  27   2              for(i=0; i<MAX_TASKS; i++)
  28   2              {
  29   3                  if(os_tcb[i].os_task_wait_tick)
  30   3                  {
  31   4                      os_tcb[i].os_task_wait_tick--;
  32   4                      if(os_tcb[i].os_task_wait_tick == 0)
  33   4                      {
  34   5                          os_task_rdy_tbl |= os_map_tbl[i];
  35   5                      }
  36   4                  }
  37   3              }
  38   2          }
  39   1          else { os_hrtos_wait=1; }
  40   1          for(i=0; i<j; i++)   //保护
  41   1          {
  42   2              os_task_stack[os_task_running_id][i]=os_hrtos_stack[i];
  43   2          }
  44   1          for (i=os_task_running_id+1; i<MAX_TASKS; i++)//筛选
  45   1          {
  46   2              if(os_task_rdy_tbl&os_map_tbl[i])
  47   2              {
  48   3                  break;
  49   3              }
  50   2          }
  51   1          if(i==MAX_TASKS)
  52   1          {
  53   2                      for (i=0; i<=os_task_running_id; i++)
  54   2              {
  55   3                  if(os_task_rdy_tbl&os_map_tbl[i])
C51 COMPILER V9.00   HRTOS_MINI                                                            12/22/2018 18:13:08 PAGE 2   

  56   3                  {
  57   4                      break;
  58   4                  }
  59   3              }
  60   2          }
  61   1      OS_HRT:
  62   1              os_task_running_id = i;//选择
  63   1          j= os_tcb[os_task_running_id].os_task_stack_top-OS_ST-os_stack;
  64   1          for(i=0; i<j; i++)   //恢复
  65   1          {
  66   2              os_hrtos_stack[i]=os_task_stack[os_task_running_id][i];
  67   2          }
  68   1          SP = os_tcb[os_task_running_id].os_task_stack_top;
  69   1      }
  70          void os_init(void)
  71          {
  72   1          EA = 0;
  73   1          ET0 = 1;
  74   1          TMOD|=0X01;
  75   1          TH0 = 0x00;
  76   1          TL0 = 0x00;
  77   1          os_task_rdy_tbl = 0;
  78   1          os_stack=(unsigned char)os_hrtos_stack;
  79   1              os_stack--;
  80   1          os_hrtos_wait=1;
  81   1          os_en_cr_count = 0;
  82   1      }
  83          void os_task(unsigned char task_id ,unsigned int task_point)
  84          {
  85   1          os_enter_critical();
  86   1          os_task_stack[task_id][0] = task_point;//地址
  87   1          os_task_stack[task_id][1] = task_point>>8;
  88   1          os_tcb[task_id].os_task_stack_top = os_stack+11;
  89   1          os_task_rdy_tbl |= os_map_tbl[task_id];//生效
  90   1          os_tcb[task_id].os_task_wait_tick = 0; //延时
  91   1          os_exit_critical();
  92   1      }
  93          void os_start(void)
  94          {
  95   1          os_task_running_id = MAX_TASKS;
  96   1          os_hrtos_stack[0]=os_task_stack[0][0];
  97   1          os_hrtos_stack[1]=os_task_stack[0][1];
  98   1          EA = 1;
  99   1          TR0 = 1;
 100   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =    335    ----
   CONSTANT SIZE    =      8    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     80       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      1    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
